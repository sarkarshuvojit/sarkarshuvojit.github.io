<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Shuvojit's Blog]]></title><description><![CDATA[Shuvojit's Blog]]></description><link>https://blog.shuvojit.in</link><generator>RSS for Node</generator><lastBuildDate>Sat, 09 Sep 2023 22:52:49 GMT</lastBuildDate><atom:link href="https://blog.shuvojit.in/rss.xml" rel="self" type="application/rss+xml"/><language><![CDATA[en]]></language><ttl>60</ttl><atom:link rel="next" href="https://blog.shuvojit.in/rss.xml?page=1"/><item><title><![CDATA[How to make sense of error logs?]]></title><description><![CDATA[<p><strong>Errors</strong> are scary for most people; especially when starting off. </p>
<p>Im not talking about the scenario where you expect a certain result and get something else; that might be related more to the code you personally wrote.</p>
<p>Im specifically talking of a scenario when you either got started up at a new place with a completely new project; maybe the framework is new for you; maybe they have a custom-made framework for their org.</p>
<p>One day while working on a task; you somehow introduced a bug that throws some sort of exception which you have no idea why it came nor can you deduce how your code could have broken anything. You dont even know the codebase well enough to be able to figure out remotely what couldve caused it.</p>
<p>During a time like this, you can either get overwhelmed by that 200 lines of errors; or calmly befriend them. As it is the only thing that can help you understand the issue the quickest; not solve, but understand.</p>
<p>Error messages might not specifically help you fix the issue or come up with a solution, but theyre a great tool to understand what went wrong.</p>
<p>In layman terms, the gibberish that gets printed when your code fails is known as a stack trace.</p>
<h2 id="heading-understanding-stack-traces">Understanding Stack-Traces</h2>
<p>For example, you have a piece of code that starts executing from a file called A, calls a function in file B, and B, in turn, calls a function in C; something goes wrong in C and it throws an exception Ec; which if not handled, will result in the program to exit with non-zero code. For such a scenario, you can always assume that the info about C will come first followed by B and A.</p>
<p>Theres a very special reason for this as well; since thinking outside-in in a scenario like this wouldnt really help much for a developer to understand the context as well. As when you start from the outside you have a lot of context to understand and process till you reach that line that actually throws an error. And also have to think about code that might not even be related to the error youre trying to debug.</p>
<p>So the better way is to look inside-out; you start with looking at the most minimal context and try to figure out the reason why it failed; failed to understand? Ok, increase a level of context, now you can look at B which is called C, and figure out what mightve gone wrong there, and just move contexts up and gradually build up on it until you figure out what actually went wrong.</p>
<h2 id="heading-what-does-it-look-like">What does it look like?</h2>
<p>Generally speaking, a stack trace will start with the name of an exception(or error); it will provide some background information about it and then there will be N number of lines starting from where the exception originated in leading up to where the execution began from.</p>
<p>Most probably, each line of the stack trace will also contain some information about which function/method the exception originated from, and additionally also provide information about the file and even the line number where it happened.</p>
<p>For example:</p>
<pre><code>caused by SomeException
    at someClass.someFunction(SomeFileName.someExt:lineNumber)
    at someClass.someFunction(SomeFileName.someExt:lineNumber)
</code></pre><h2 id="heading-needle-in-a-haystack-recognising-lines-of-interest">Needle in a haystack - Recognising lines of interest</h2>
<p>I feel like stating the obvious, but the quickest way to understand the reason why some error came lies in trying to understand the flow of control leading up to the error; i.e. how did the flow of control reach that point of failure; and what was the path in terms of lines of code it travels.</p>
<p>However, it may not seem obvious when we think about how modern software development works; we mostly use a framework or a bunch of library functions to get started. And while we try to manifest the app we want to create, we often end up using a lot of functions that we ourselves have not written; aka library code. </p>
<p>So, realistically in a stack trace, you can expect only at most 5 lines in a stack trace to be significant enough for you to pay attention to; but those 5 lines will be hidden within a plethora of methods from the framework or library which is being used.</p>
<p>So, the lines you need to be paying attention to are basically lines that are from your project; as those are the only lines where you might have added something which would break the app.</p>
<p>This is where IDEs can be of good help; most good IDE has this amazing feature where while showing errors they highlight all the files that belong to your project and are written by you as well as gives a link over it, upon clicking which the exact file and line is opened on that IDE.</p>
<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1664315080378/TBNEQT6dG.png" alt="Image of an error log in Intellij Community." /></p>
<p>In the above image, we can see a stack trace of what seems like a validatePassword gone wrong. You can very easily just glance and locate the orange lines, and you will notice that all of those lines start with <strong>com.company</strong> which is the package name for the current project.</p>
<p>This is how IDEs may help in this first step of zoning into specific lines from a bigger stack trace. </p>
<h2 id="heading-avoid-this-silly-mistake">Avoid this silly mistake</h2>
<p>A lot of people; to be safe tend to wrap their code in try-catch blocks while catching the <code>java.lang.Exception</code> class. This is scary; as now all the exceptions the programmer hasnt even thought about getting caught and since the bubbling of that event is stopped, it gets very hard to catch or debug that issue. As there will be no stacktrace for it at all.</p>
<p>Im talking about a code somewhat like this </p>
<pre><code class="lang-java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">try</span> {
        someService.createSomeThing();
    <span class="hljs-keyword">catch</span> (Exception ex) {
        logger.error(<span class="hljs-string">"Something went wrong"</span>, ex);
    }
}
</code></pre>
<p>If the code is like this; and somehow the database goes down, instead of throwing a scary 500 which will prompt everyone to quickly look at it, it will silently handle that error and just provide a log statement as a response. Even while trying to investigate in such a scenario when someone will look into the logs they will only see the classname of the error that happened, and thats it.</p>
<p>One thing that <strong>can</strong> be done(not should) is on top of just printing the <code>ex</code> we can also log <code>ex.getStackTrace()</code> to be sure that in such scenarios atleast the whole stacktrace is logged for us to then read and understand the issue.</p>
<p>However, what I think should be done is we should only handle exceptions that we expect; anything else that we didnt probably means it is something that should fail our app.</p>
<p>As an example; lets say you have a <code>createUserName</code> method which creates a userName for a specific user. If you know it can only throw two exceptions, <code>UserNameAlreadyExists</code> or <code>UserNameFormatInvalid</code>; then you should only handle those two exceptions and handle them accordingly and not catch <code>java.lang.Exception</code> as that means you will literally catch all exceptions that might happen downstream.</p>
<h2 id="heading-find-out-exactly-what-to-google">Find out exactly what to google</h2>
<p>Lets say now youve gotten comfortable at looking at stacktrace, and you know where to look at and also how to locate lines relevant for you, the next simple step is googling. Learning how to read stacktrace will give you exactly what you need to google to understand the issue.</p>
<p>For example; lets say you have a big stacktrace, and you locate 3lines of it where your own code is mentioned, and at the topmost entry an exception is thrown that you have never heard of, this is the time to just google the specific name, learn about it and think how your code could have thrown it; as massive hints you now know exactly which lines to look at in exactly which files; which will make this process a bit faster.</p>
<h2 id="heading-closing-thoughts">Closing thoughts</h2>
<p>This was a very basic guide; however every language and framework has a few things slightly different and you might need to fine-tune those while working to be at an advantage; for example with Laravel; whenever a 500 is thrown in a debug-enabled environment, the error page includes all the environment variables that were set and all the request params that came in for the request. So if you know about that, debugging an issue that is related to a wrong or cached environment variable will be a breeze.</p>
]]></description><link>https://blog.shuvojit.in/how-to-make-sense-of-error-logs</link><guid isPermaLink="true">https://blog.shuvojit.in/how-to-make-sense-of-error-logs</guid><dc:creator><![CDATA[Shuvojit Sarkar]]></dc:creator><pubDate>Tue, 27 Sep 2022 22:29:30 GMT</pubDate><cover_image>https://cdn.hashnode.com/res/hashnode/image/upload/v1664317485225/5bRqh4brb.png</cover_image></item></channel></rss>
